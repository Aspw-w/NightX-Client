package net.aspw.client.features.module.impl.exploit

import net.aspw.client.event.EventTarget
import net.aspw.client.event.PacketEvent
import net.aspw.client.event.UpdateEvent
import net.aspw.client.features.module.Module
import net.aspw.client.features.module.ModuleCategory
import net.aspw.client.features.module.ModuleInfo
import net.aspw.client.util.HandlePacket
import net.aspw.client.value.IntegerValue
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayClient
import net.minecraft.network.play.server.S23PacketBlockChange
import java.util.concurrent.LinkedBlockingQueue

@ModuleInfo(
    name = "FakeGhostBlock",
    spacedName = "Fake Ghost Block",
    description = "",
    category = ModuleCategory.EXPLOIT
)
class FakeGhostBlock : Module() {
    private val delay = IntegerValue("Duration", 1000, 0, 2000)

    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayClient>>()
    private val times = ArrayList<Long>()

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (packet is S23PacketBlockChange) {
            event.cancelEvent()
            times.add(System.currentTimeMillis())
            packets.add(packet as Packet<INetHandlerPlayClient>)
        }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        while (times.isNotEmpty() && times.first() < System.currentTimeMillis() - delay.get().toLong()) {
            HandlePacket.handlePacket(packets.take() as Packet<INetHandlerPlayClient?>)
            times.remove(times.first())
        }
    }

    override fun onEnable() {
        packets.clear()
        times.clear()
    }

    override fun onDisable() {
        while (!packets.isEmpty()) {
            HandlePacket.handlePacket(packets.take() as Packet<INetHandlerPlayClient?>)
        }
        times.clear()
    }
}